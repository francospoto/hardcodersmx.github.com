<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | hardcoders.mx]]></title>
  <link href="http://hardcoders.mx/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://hardcoders.mx/"/>
  <updated>2012-12-28T11:14:18-07:00</updated>
  <id>http://hardcoders.mx/</id>
  <author>
    <name><![CDATA[hardcoders.mx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objetos en Javascript]]></title>
    <link href="http://hardcoders.mx/blog/2012/12/27/objetos-en-javascript/"/>
    <updated>2012-12-27T19:00:00-07:00</updated>
    <id>http://hardcoders.mx/blog/2012/12/27/objetos-en-javascript</id>
    <content type="html"><![CDATA[<p>En Javascript hay diversas formas de crear objetos, todas son válidas y sirven para cumplir diversos propósitos. Javascript está basado en prototipos y no en clases (como Java o C#). En este tutorial veremos:</p>

<ul>
<li>Objetos simples.</li>
<li>Objetos literales.</li>
<li>Funciones como constructores.</li>
<li>Herencia.</li>
</ul>


<!-- more -->


<h2>Objetos Simples</h2>

<p>La forma más simple de crear un objeto es instanciar un objeto de tipo <code>Object</code> y agregarle las propiedades y métodos dinámicamente:</p>

<p>```javascript Objetos simples
var persona = new Object();
persona.nombre = "Isaac";
persona.edad = 28;
persona.imprimir = function() {</p>

<pre><code>alert(this.nombre + ' ' + this.edad);
</code></pre>

<p>};</p>

<p>persona.imprimir(); // Mostrará un alert "Isaac 28"
```</p>

<p>Cuando agregamos propiedades de forma dinámica, estas solo se agregan al objeto en cuestión y nuevos objetos instanciados no tendrán estas propiedades:</p>

<p>```javascript
var persona = new Object();
persona.nombre = "Isaac";</p>

<p>var persona2 = new Object();</p>

<p>alert(persona.nombre); // Muestra "Isaac"
alert(persona2.nombre); // Muestra "undefined"
```</p>

<h2>Objetos Literales</h2>

<p><del>También podemos crear objetos usando el Javascript Object Notation (JSON).</del></p>

<p><strong>Nota Aclaratoria:</strong> usar objetos literales no significa usar JSON, JSON es una notación basada ó influenciada por la sintaxis de los objetos literales de Javascript. Un object literal es una manera de definir un objeto conforme a la sintaxis definida de Javascript. JSON en cambio es un formato de intercambio de información que se codifica con un formato similar al definido para los objetos literales. <em>(Gracias a Alberto Ávila por esta aclaración en sus comentarios)</em></p>

<p>En un objeto literal las propiedades son creadas como lista de pares key/value.</p>

<p>```javascript Objetos literales
var persona = {</p>

<pre><code>nombre: "Isaac",
edad: 28,
imprimir: function() {
    alert(this.nombre + " " + this.edad);
}
</code></pre>

<p>};</p>

<p>persona.nombre = "Isaac Zepeda"; // Puedo modificar sus propiedades
persona.imprimir(); // E invocar sus métodos
```</p>

<h2>Funciones como constructores</h2>

<p>Como pueden notar cuando construimos objetos simples o literales no hay manera de crear nuevas o varias instancias de estos objetos, digamos que necesito un objeto <code>Persona</code> y crear varias instancias de el, aquí es donde entran las funciones como constructores:</p>

<p>```javascript Funciones como constructores
function Persona() {</p>

<pre><code>// Para definir variables de instancia usamos la palabra reservada 'this'
this.nombre = "Isaac"; 
this.edad = 28;

// Esta es una variable local a la función y no puede ser accedida desde fuera.
var count;
</code></pre>

<p>}</p>

<p>// Para instanciar un nuevo objeto usamos la palabra reservada new
var persona1 = new Persona();
var persona2 = new Persona();
alert(persona1.nombre); // Isaac</p>

<p>persona2.nombre = "Pancho";
alert(persona2.nombre); // Pancho</p>

<p>// undefined, no se puede acceder ya que es una variable local no de instancia
alert(persona1.count);
```</p>

<p>Ahora podemos pasarle valores al constructor para que establezca <code>nombre</code> y <code>edad</code> con el valor que nos plazca, y si no están definidos que tome un valor por default usando el operador <code>||</code>.</p>

<p>```javascript Constructor con argumentos
function Persona(nombre, edad) {</p>

<pre><code>// si nombre es indefinido o nulo tomará el valor "Isaac"
this.nombre = nombre || "Isaac";
this.edad = edad || 28;
</code></pre>

<p>}</p>

<p>var p1 = new Persona("Alberto", 17);
var p2 = new Persona();
```</p>

<h3>Agregando Métodos</h3>

<p>Hay dos maneras de agregar métodos, la primera es agregarlos como cualquier otra propiedad dentro del constructor y la otra definiendolo es su <code>prototype</code>.</p>

<p>```javascript Defiendo el método dentro del constructor
function Persona() {</p>

<pre><code>this.nombre = "Isaac";

this.caminar = function() {
    alert(this.name + " está caminando");
}
</code></pre>

<p>}
```</p>

<p>```javascript Definiendo el método es su prototype
function Persona() {</p>

<pre><code>this.nombre = "Isaac";
</code></pre>

<p>}</p>

<p>Persona.prototype.caminar = function() {</p>

<pre><code>alert(this.name + " está caminando");
</code></pre>

<p>}
```</p>

<p>Ambos funcionan correctamente, pero hay pequeñas diferencias.</p>

<p>Si se define el método dentro del constructor cada vez que se instancie el objeto creará una propiedad con un objeto de tipo función, así si el objeto <code>Persona</code> se instancia 3 veces se crearán 3 funciones en memoria que hacen lo mismo. En cambio si lo creamos en el <code>prototype</code> la función se creará solo una vez, y todas las instancias de <code>Persona</code> apuntarán a la misma función, usando menos memoria y mejorando un poco el performance.</p>

<p>Sin embargo, cuando creamos un método en el <code>prototype</code>, este no puede acceder a las variables locales del constructor:</p>

<p>```javascript Accediendo a variables locales
function Persona() {</p>

<pre><code>var count = 1;

this.caminar = function() {
    alert(count); // Muestra 1;
}
</code></pre>

<p>}</p>

<p>Persona.prototype.correr = function() {</p>

<pre><code>alert(count); // Dará error ya que count no esta definida
</code></pre>

<p>}
```</p>

<p>El <code>prototype</code> es un objeto que tienen todos los objetos en Javascript, cuando queremos acceder a una propiedad <code>Persona.nombre</code> Javascript busca la propiedad en el objeto mismo, si no lo encuentra va lo busca al <code>prototype</code>, si no la encuentra busca dentro del <code>prototype</code> del objeto <code>prototype</code>, esto se conoce como <em>prototype-chain</em> y nos sirve para la herencia.</p>

<h2>Herencia</h2>

<p>A través del <em>prototype-chain</em> podemos tener herencia en Javascript.</p>

<p>Supongamos que tenemos un tipo padre <code>Mamifero</code> que tiene el método <code>caminar</code> y <code>ver</code>. Luego tenemos un hijo <code>Humano</code> que sobreescribe al método <code>caminar</code> y agrega un nuevo método <code>correr</code>.</p>

<p>Para heredar <code>Humano</code> de <code>Mamifero</code>, el objeto <code>prototype</code> de <code>Humano</code> debe contener una instancia de su padre, en este caso <code>Mamifero</code>.</p>

<p>```javascript Herencia
// Definimos al padre
function Mamifero() {</p>

<pre><code>this.extremidades = 4;
</code></pre>

<p>}</p>

<p>Mamifero.prototype.ver = function() {</p>

<pre><code>alert('El mamífero ve.');
</code></pre>

<p>}</p>

<p>Mamifero.prototype.caminar = function() {</p>

<pre><code>alert('El mamífero camina con ' + this.extremidades + ' extremidades.');
</code></pre>

<p>}</p>

<p>// Definimos al hijo
function Humano() {</p>

<pre><code>this.extremidades = 2;
this.nombre = "Isaac";
</code></pre>

<p>}</p>

<p>// Le decimos quien es su padre
Humano.prototype = new Mamifero();</p>

<p>// Reescribimos y agregamos los métodos de Humano
Humano.prototype.caminar = function() {</p>

<pre><code>alert('El humano camina con ' + this.extremidades + ' extremidades.');
</code></pre>

<p>}</p>

<p>Humano.prototype.correr = function() {</p>

<pre><code>alert('El humano corre');
</code></pre>

<p>}</p>

<p>var perro = new Mamifero();
var persona = new Humano();</p>

<p>perro.ver(); // Método definidio en Mamifero
perro.caminar(); // Llama al método en Mamifero</p>

<p>persona.ver(); // Llama al método definido en Mamifero
persona.caminar(); // Llama al método sobreescrito en Humano
persona.correr(); // Llama al método definido en Humano que no existe en Mamifero
```</p>

<p>El objeto <code>Humano.prototype</code> es un objeto de tipo <code>Mamifero</code> (línea 21), luego agreamos dinámicamente métodos a ese prototipo (líneas 24, 25). Como <code>Mamifero</code> es un objeto el también tiene un propiedad <code>prototype</code> al cual se le defineron 2 métodos (líneas 6, 10).</p>

<p>Entonces, cuando invocamos el método <code>persona.caminar()</code> Javascript busca en el objeto mismo, no lo encuentra y busca en su prototipo (<code>Humano.prototype.caminar</code>), lo encuentra y lo invoca.</p>

<p>Cuando invocamos el método <code>persona.ver()</code> Javascript busca en el objeto mismo, no lo encuentra, luego busca en su prototipo (<code>Humano.prototype.ver</code>), no lo encuentra, y se va en la cadena de prototipos hasta que lo encuentre en este caso <code>Humano.prototype.prototype.ver</code>, ya que <code>Humano.prototype.prototype</code> apunta a <code>Mamifero.prototype</code>.</p>

<p>Espero que haya quedado claro esto del <code>prototype</code>.</p>

<h2>Bibliografía</h2>

<p>Para saber más acerca de los objetos y de la propiedad <code>prototype</code>:</p>

<ul>
<li><a href="http://helephant.com/2008/08/17/how-javascript-objects-work/">How Javascript objects work</a></li>
<li><a href="http://net.tutsplus.com/tutorials/javascript-ajax/prototypes-in-javascript-what-you-need-to-know/">Prototypes in JavaScript</a></li>
<li><a href="http://stackoverflow.com/questions/572897/how-does-javascript-prototype-work">How does JavaScript .prototype work?</a></li>
<li><a href="http://stackoverflow.com/questions/6163186/prototype-or-inline-what-is-the-difference">Prototype or inline, what is the difference?</a></li>
<li><a href="http://stackoverflow.com/questions/5529285/prototype-chaining-constructor-inheritance">Prototype chaining, Constructor, Inheritance</a></li>
<li><a href="http://javascript.crockford.com/prototypal.html">Prototypal Inheritance in JavaScript</a></li>
</ul>


<p>Bienvenidos sean sus comentarios, sugerencias, dudas, etc.</p>
]]></content>
  </entry>
  
</feed>
